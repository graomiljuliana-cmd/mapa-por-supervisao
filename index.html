<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>Mapa de Supervis√µes - Cidades</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    crossorigin=""
  />

  <style>
    html, body {
      margin: 0;
      height: 100%;
      width: 100%;
      font-family: Arial, sans-serif;
    }
    #map {
      height: 100%;
      width: 100%;
    }
    .panel {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 1000;
      background: #fff;
      padding: 10px;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.25);
      font-size: 13px;
      max-width: 260px;
    }
    .panel h4 {
      margin: 0 0 6px 0;
      font-size: 14px;
    }
    .panel select {
      width: 100%;
      padding: 4px;
      margin-bottom: 6px;
    }
    .legend-item {
      display: flex;
      align-items: center;
      margin-bottom: 3px;
      cursor: pointer;
      padding: 2px 4px;
      border-radius: 4px;
    }
    .legend-item:hover {
      background: #f0f0f0;
    }
    .legend-item.selected {
      background: #e0f5e9;
      font-weight: bold;
    }
    .legend-color {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      border: 1px solid #333;
      margin-right: 5px;
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <div class="panel">
    <h4>Filtro de Supervis√£o</h4>
    <select id="filtro">
      <option value="">Todas</option>
    </select>
    <div id="legenda"></div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <!-- Turf.js para unir pol√≠gonos por supervis√£o -->
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>

  <script>
    /**************** CONFIG ****************/
    const WEBAPP_URL =
      "https://script.google.com/macros/s/AKfycbwnpVZijStuBl7uL1ONtJdP8or97kS0QKj8mQ111vbCNxeMOaBMvfXLI37F8XiKw2E/exec";

    const MUNICIPIOS_GEOJSON = "municipios-br.geojson";

    // base auxiliar com UF por c√≥digo IBGE
    const MUNICIPIOS_META_URL =
      "https://raw.githubusercontent.com/kelvins/municipios-brasileiros/main/json/municipios.json";

    // Mapa c√≥digo_uf -> sigla UF
    const UF_MAP = {
      11:"RO", 12:"AC", 13:"AM", 14:"RR", 15:"PA", 16:"AP", 17:"TO",
      21:"MA", 22:"PI", 23:"CE", 24:"RN", 25:"PB", 26:"PE", 27:"AL", 28:"SE", 29:"BA",
      31:"MG", 32:"ES", 33:"RJ", 35:"SP",
      41:"PR", 42:"SC", 43:"RS",
      50:"MS", 51:"MT", 52:"GO", 53:"DF"
    };

    let map;
    let layerMunicipios;
    let layerSupOutlines;      // NOVA camada para contornos por supervis√£o

    // chaves "CIDADE|UF" -> supervis√£o
    let cidadeParaSupervisao = {};

    // features agrupadas por supervis√£o normalizada (para fazer union)
    let featuresPorSup = {};

    /*************** CORES COM MAIS CONTRASTE (NOVA) ***************/
    const BASE_COLORS = [
      "#e6194B", "#800000", "#ff0000", "#ffa500", "#ff7f00",
      "#ffd700", "#b8860b", "#9acd32", "#32cd32", "#008000",
      "#006400", "#00fa9a", "#40e0d0", "#00ced1", "#1e90ff",
      "#0000ff", "#00008b", "#9932cc", "#8a2be2", "#ff00ff",
      "#ff1493", "#c71585", "#ff69b4", "#ff4500", "#dc143c"
    ];

    // supNorm -> cor
    let supColorMap = {};

    // distribui cores espa√ßando √≠ndices para aumentar contraste
    function buildSupColorMap(supListNorm) {
      const n = BASE_COLORS.length;
      if (n === 0) return;

      const step = 7; // n√∫mero coprimo ao tamanho t√≠pico da paleta
      let idx = 0;

      supListNorm.forEach(supNorm => {
        supColorMap[supNorm] = BASE_COLORS[idx % n];
        idx = (idx + step) % n;
      });
    }

    function corPara(supOuNorm) {
      const key = normalizar(supOuNorm);
      return supColorMap[key] || "#999999";
    }

    let GEO_CITY_FIELD = null;
    let GEO_UF_FIELD   = null;

    // UF por c√≥digo IBGE do munic√≠pio (id do GeoJSON)
    let UF_POR_ID = {};

    /**************** UTILS ****************/
    function normalizar(str) {
      if (!str) return "";
      return String(str)
        .normalize("NFD")
        .replace(/[\u0300-\u036f]/g, "")
        .replace(/[^A-Za-z0-9 ]/g, " ")
        .replace(/\s+/g, " ")
        .trim()
        .toUpperCase();
    }

    function chaveCidadeUF(c, u) {
      return normalizar(c) + "|" + normalizar(u || "");
    }

    function detectarCamposCidadeUF(exemploProps) {
      const keys = Object.keys(exemploProps);

      // UF: tenta campo com "UF" ou "STATE"
      for (const k of keys) {
        const up = k.toUpperCase();
        if (up.includes("UF") || up.includes("STATE")) {
          GEO_UF_FIELD = k;
          break;
        }
      }

      // Cidade: preferidos
      const preferidos = ["NM_MUN","NM_MUNICIP","MUNICIP","MUNICIPIO","NOME","NAME"];
      for (const pref of preferidos) {
        const kFound = keys.find(k => k.toUpperCase() === pref);
        if (kFound) {
          GEO_CITY_FIELD = kFound;
          break;
        }
      }
      // fallback: primeiro campo string "normal"
      if (!GEO_CITY_FIELD) {
        for (const k of keys) {
          const v = exemploProps[k];
          if (typeof v === "string" && k !== "id" && k.toLowerCase() !== "description") {
            GEO_CITY_FIELD = k;
            break;
          }
        }
      }

      console.log("Campos detectados no GeoJSON:", {
        GEO_CITY_FIELD,
        GEO_UF_FIELD,
        exemplo: exemploProps
      });
    }

    function obterCidadeUF(props) {
      const cidade = GEO_CITY_FIELD ? (props[GEO_CITY_FIELD] || "") : "";
      let uf       = GEO_UF_FIELD   ? (props[GEO_UF_FIELD]   || "") : "";

      // se o GeoJSON n√£o tem UF, tentamos buscar pelo id IBGE
      if (!uf && props.id && UF_POR_ID[String(props.id)]) {
        uf = UF_POR_ID[String(props.id)];
      }

      return { cidade, uf };
    }

    // ‚ûú SOMENTE CIDADE+UF EXATO
    function chaveGeoParaMapa(cidade, uf) {
      const chaveFull = chaveCidadeUF(cidade, uf);
      return cidadeParaSupervisao[chaveFull] ? chaveFull : null;
    }

    /**************** MAIN ****************/
    async function iniciar() {
      try {
        map = L.map("map").setView([-15.8, -47.9], 5);
        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
          maxZoom: 18
        }).addTo(map);

        // 1) WebApp (planilha)
        const dadosPlanilha = await fetch(WEBAPP_URL).then(r => r.json());
        if (!Array.isArray(dadosPlanilha)) {
          console.error("WebApp retornou:", dadosPlanilha);
          alert("Erro ao carregar dados da planilha (WebApp). Veja o console.");
          return;
        }

        const supNormsSet = new Set();

        dadosPlanilha.forEach(p => {
          const cidadeNorm = normalizar(p.cidade);
          const ufNorm     = normalizar(p.uf);
          const sup        = p.supervisao;

          // exige CIDADE + UF + supervis√£o
          if (!cidadeNorm || !ufNorm || !sup) return;

          const chaveFull = cidadeNorm + "|" + ufNorm;
          cidadeParaSupervisao[chaveFull] = sup;

          supNormsSet.add(normalizar(sup));
        });

        // monta mapa de cores antes de desenhar
        const listaSupNorm = [...supNormsSet].sort();
        buildSupColorMap(listaSupNorm);

        console.log("Total de cidades da planilha:", Object.keys(cidadeParaSupervisao).length);
        console.log("Supervis√µes (normalizadas):", listaSupNorm);

        // 2) Baixa metadados IBGE (para descobrir UF por id)
        const municipiosMeta = await fetch(MUNICIPIOS_META_URL).then(r => r.json());
        UF_POR_ID = {};
        municipiosMeta.forEach(m => {
          const uf = UF_MAP[m.codigo_uf];
          if (uf) {
            UF_POR_ID[String(m.codigo_ibge)] = uf;
          }
        });
        console.log("Total de c√≥digos IBGE com UF mapeada:", Object.keys(UF_POR_ID).length);

        // 3) GeoJSON de munic√≠pios
        const geojson = await fetch(MUNICIPIOS_GEOJSON).then(r => r.json());
        if (!geojson.features || !geojson.features.length) {
          alert("GeoJSON sem features.");
          return;
        }

        detectarCamposCidadeUF(geojson.features[0].properties);

        let contComSup = 0;

        // zera agrupamento
        featuresPorSup = {};

        layerMunicipios = L.geoJSON(geojson, {
          // s√≥ desenha cidade presente na planilha (cidade+UF)
          filter: feat => {
            const props = feat.properties || {};
            const { cidade, uf } = obterCidadeUF(props);
            const chave = chaveGeoParaMapa(cidade, uf);
            if (!chave) return false;

            const sup = cidadeParaSupervisao[chave];
            if (!sup) return false;

            const supNorm = normalizar(sup);

            feat.properties._sup = sup;
            feat.properties._supNorm = supNorm;
            contComSup++;

            // guarda feature por supervis√£o para depois fazer union dos pol√≠gonos
            if (!featuresPorSup[supNorm]) {
              featuresPorSup[supNorm] = [];
            }
            featuresPorSup[supNorm].push(feat);

            return true;
          },
          style: feat => {
            const sup = feat.properties._sup;
            const cor = corPara(sup);
            return {
              // blocos coloridos (munic√≠pios)
              stroke: false,
              color: cor,
              weight: 0,
              fillColor: cor,
              fillOpacity: 0.5
            };
          },
          onEachFeature: (feat, layer) => {
            const props = feat.properties || {};
            const { cidade, uf } = obterCidadeUF(props);
            const sup = props._sup;

            layer._sup = sup || null;
            layer._supNorm = props._supNorm || null;

            if (sup) {
              layer.bindPopup(
                `<strong>${cidade}${uf ? " - " + uf : ""}</strong><br>Supervis√£o: ${sup}`
              );
            }
          }
        }).addTo(map);

        console.log("Munic√≠pios desenhados (com supervis√£o):", contComSup);

        // 4) Cria camada de contornos unificados por supervis√£o
        criarLayerContornosSupervisao();

        montarFiltroELegenda();

        if (contComSup === 0) {
          alert("Nenhuma cidade casou com o GeoJSON. Veja o console (F12).");
        }

      } catch (err) {
        console.error(err);
        alert("Erro ao carregar mapa: " + err.message);
      }
    }

   function criarLayerContornosSupervisao() {
  if (!window.turf) {
    console.warn("Turf.js n√£o carregado, contornos unificados desativados.");
    return;
  }

  layerSupOutlines = L.geoJSON(null, {
    style: feat => {
      const supNorm = feat.properties._supNorm;
      const cor = corPara(supNorm);
      return {
        color: cor,
        weight: 3,
        fillOpacity: 0,
        opacity: 1
      };
    },
    // üëá importante: contorno s√≥ visual, n√£o captura clique
    interactive: false
  }).addTo(map);

  // opcional: joga o contorno para tr√°s dos tiles, mas continua vis√≠vel
  layerSupOutlines.bringToBack();

  Object.entries(featuresPorSup).forEach(([supNorm, feats]) => {
    if (!feats || !feats.length) return;

    let unionFeature = null;

    try {
      feats.forEach((f, idx) => {
        const feat = {
          type: "Feature",
          properties: {},
          geometry: f.geometry
        };
        if (idx === 0) {
          unionFeature = feat;
        } else {
          unionFeature = turf.union(unionFeature, feat);
        }
      });

      if (unionFeature && unionFeature.geometry) {
        unionFeature.properties = unionFeature.properties || {};
        unionFeature.properties._supNorm = supNorm;
        layerSupOutlines.addData(unionFeature);
      }
    } catch (e) {
      console.error("Erro ao unir pol√≠gonos da supervis√£o", supNorm, e);
    }
  });

  console.log("Camada de contornos por supervis√£o criada.");
}

    function montarFiltroELegenda() {
      const select  = document.getElementById("filtro");
      const legenda = document.getElementById("legenda");
      const sups = new Set();

      layerMunicipios.eachLayer(l => {
        if (l._supNorm) sups.add(l._supNorm);
      });

      const lista = [...sups].sort();
      console.log("Supervis√µes detectadas no mapa (para legenda):", lista);

      lista.forEach(s => {
        // dropdown
        const opt = document.createElement("option");
        opt.value = s;
        opt.textContent = s;
        select.appendChild(opt);

        // legenda
        const item = document.createElement("div");
        item.className = "legend-item";
        item.dataset.supNorm = s;

        const corDiv = document.createElement("div");
        corDiv.className = "legend-color";
        corDiv.style.background = supColorMap[s] || "#999999";

        const label = document.createElement("span");
        label.textContent = s;

        item.appendChild(corDiv);
        item.appendChild(label);
        legenda.appendChild(item);

        // clique na legenda = aplica filtro
        item.addEventListener("click", () => {
          const supNorm = item.dataset.supNorm;
          select.value = supNorm;
          aplicarFiltro(supNorm);
          marcarLegendaSelecionada(supNorm);
        });
      });

      select.onchange = () => {
        const v = select.value || "";
        aplicarFiltro(v);
        marcarLegendaSelecionada(v);
      };
    }

    function marcarLegendaSelecionada(supNorm) {
      document.querySelectorAll(".legend-item").forEach(el => {
        if (supNorm && el.dataset.supNorm === supNorm) {
          el.classList.add("selected");
        } else {
          el.classList.remove("selected");
        }
      });
    }

    function aplicarFiltro(supNorm) {
      let boundsMun = null;
      let boundsSup = null;

      // controla visibilidade dos munic√≠pios (preenchimento)
      layerMunicipios.eachLayer(l => {
        const sup = l._sup;
        if (!sup) return;

        const visivel = !supNorm || l._supNorm === supNorm;

        l.setStyle({
          opacity: visivel ? 1 : 0,
          fillOpacity: visivel ? 0.5 : 0
        });

        if (visivel) {
          const b = l.getBounds && l.getBounds();
          if (b) boundsMun = boundsMun ? boundsMun.extend(b) : b;
        }
      });

      // controla visibilidade dos contornos unificados
      if (layerSupOutlines) {
        layerSupOutlines.eachLayer(l => {
          const feat = l.feature || {};
          const props = feat.properties || {};
          const supN = props._supNorm || "";

          const visivel = !supNorm || supN === supNorm;

          l.setStyle({
            opacity: visivel ? 1 : 0,
            weight: visivel ? 3 : 0
          });

          if (visivel) {
            const b = l.getBounds && l.getBounds();
            if (b) boundsSup = boundsSup ? boundsSup.extend(b) : b;
          }
        });
      }

      const bounds = boundsSup || boundsMun;
      if (bounds) map.fitBounds(bounds);
    }

    iniciar();
  </script>
</body>
</html>

